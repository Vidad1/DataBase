vidadi@Vidadis-MacBook-Pro ~ % psql -U vidadi -d mydb -h localhost -p 5432
psql (15.14 (Homebrew))
Type "help" for help.

mydb=# -- Export data from a table to CSV
mydb=# COPY employees TO '/tmp/employees.csv' WITH CSV HEADER;
COPY 25

mydb=# -- Import data into a table from CSV
mydb=# COPY employees FROM '/tmp/employees.csv' WITH CSV HEADER;
COPY 25

mydb=# -- Export with custom delimiter and NULL representation
mydb=# COPY employees TO '/tmp/employees.txt' WITH DELIMITER '|' NULL 'N/A' CSV HEADER;
COPY 25

mydb=# -- Import specific columns only
mydb=# COPY employees(first_name, last_name, email) 
mydb-# FROM '/tmp/new_employees.csv' WITH CSV HEADER;
COPY 10

mydb=# -- Export query results directly
mydb=# COPY (SELECT * FROM employees WHERE department = 'IT') 
mydb-# TO '/tmp/it_employees.csv' WITH CSV HEADER;
COPY 6


mydb=# -- Basic CSV export
mydb=# COPY products TO '/tmp/products.csv' WITH CSV HEADER;
COPY 50

mydb=# -- Custom delimiter and quote character
mydb=# COPY customers TO '/tmp/customers.csv' 
mydb-# WITH CSV HEADER DELIMITER ';' QUOTE '"';
COPY 15

mydb=# -- Export with custom date format
mydb=# COPY orders TO '/tmp/orders.csv' WITH CSV HEADER FORCE_QUOTE (order_date);
COPY 40


mydb=# -- Import CSV file into existing table
mydb=# COPY products FROM '/tmp/products.csv' WITH CSV HEADER;
COPY 50

mydb=# -- Import CSV file, ignoring bad rows
mydb=# COPY products FROM '/tmp/products_with_errors.csv' 
mydb-# WITH CSV HEADER ON_ERROR IGNORE;
COPY 48

mydb=# -- Import with UTF8 encoding
mydb=# COPY products FROM '/tmp/products_utf8.csv' 
mydb-# WITH CSV HEADER ENCODING 'UTF8';
COPY 50

mydb=# -- Handling special characters in CSV
mydb=# COPY customer_feedback TO '/tmp/feedback.csv' 
mydb-# WITH CSV HEADER DELIMITER ',' QUOTE '"' ESCAPE '"';
COPY 120

mydb=# -- Custom NULL representation
mydb=# COPY sales_data FROM '/tmp/sales.csv' WITH CSV HEADER NULL 'NULL';
COPY 75

mydb=# \! clear

vidadi@Vidadis-MacBook-Pro ~ % pg_dump -h localhost -U vidadi -d mydb > backup.sql
vidadi@Vidadis-MacBook-Pro ~ % pg_dump -h localhost -U vidadi -d mydb -Fc > backup.dump
vidadi@Vidadis-MacBook-Pro ~ % pg_dump -h localhost -U vidadi -d mydb -t employees -t products > tables_backup.sql
vidadi@Vidadis-MacBook-Pro ~ % pg_restore -h localhost -U vidadi -d mydb backup.dump
vidadi@Vidadis-MacBook-Pro ~ % pg_dumpall -h localhost -U vidadi > full_cluster_backup.sql
vidadi@Vidadis-MacBook-Pro ~ % pg_basebackup -h localhost -U replication_user -D /backup/base -Ft -z -P

sudo systemctl stop postgresql
rm -rf /var/lib/postgresql/data/*
tar -xf /backup/base/base.tar -C /var/lib/postgresql/data/

cat > /var/lib/postgresql/data/recovery.signal << EOF
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2024-01-15 14:30:00'
EOF

sudo systemctl start postgresql

vidadi@Vidadis-MacBook-Pro ~ % pg_dump -h localhost -U vidadi -d old_db -Fc > migration.dump
vidadi@Vidadis-MacBook-Pro ~ % pg_restore -h localhost -U vidadi -d new_db migration.dump

psql -U vidadi -d mydb -h localhost -p 5432
mydb=# CREATE PUBLICATION migration_pub FOR ALL TABLES;
mydb=# CREATE SUBSCRIPTION migration_sub
mydb-# CONNECTION 'host=localhost dbname=mydb user=vidadi'
mydb-# PUBLICATION migration_pub;
mydb=# CREATE TABLE staging_customers AS SELECT * FROM customers WHERE 1=0;
mydb=# COPY (SELECT * FROM customers LIMIT 10000 OFFSET 0) TO '/tmp/customers_batch_1.csv' WITH CSV HEADER;
mydb=# COPY staging_customers FROM '/tmp/customers_batch_1.csv' WITH CSV HEADER;
mydb=# INSERT INTO customers SELECT * FROM staging_customers ON CONFLICT (customer_id) DO UPDATE SET name = EXCLUDED.name;
mydb=# SELECT COUNT(*) FROM customers;
mydb=# \q
